#+TITLE: Basic Notes

* Specification and Setup

Our version of BASIC will be able to run simple programs like this:

#+BEGIN_SRC racket
#lang basic
30 rem print 'ignored'
35
50 print "never gets here"
40 end
60 print 'three' : print 1.0 + 3
70 goto 11. + 18.5 + .5 rem ignored
10 print "o" ; "n" ; "e"
20 print : goto 60.0 : end
#+END_SRC

To do this, we need to implement 4 statements:

1. print takes a string, number, or numerical expression as input and displays it, followed by a newline.
2. goto takes a number or numerical expression as input, and immediately jumps to that line of the program
3. rem starts a line comment. Anything between the rem and the next newline is ignored.
4. end immediately aborts the program

** Design

We're going to model our code above as pseudocode

#+BEGIN_SRC racket
#lang basic
(define (30) (rem print 'ignored'))
(define (35) (void))
(define (50) (print "never gets here"))
(define (40) (end))
(define (60) (print 'three') (print (+ 1.0 3)))
(define (70) (goto (+ 11. 18.5 .5) rem ignored))
(define (10) (print "o" "n" "e"))
(define (20) (print) (goto 60.0) (end))
#+END_SRC

Our program still needs to put these lines in numerical order so it knows where to start, and in which order to execute the lines (i.e., once it's done with line X, it needs to discover which line comes next). So we'll create a hash table that maps line numbers to their associated functions.

* The Lexer

#+BEGIN_SRC racket :tangle lexer.rkt
#lang br
(require brag/support)

(define-lex-abbrev digits (:+ (char-set "0123456789")))

(define basic-lexer
  (lexer-srcloc
   ["\n" (token 'NEWLINE lexeme)]                       ; handle newlines
   [whitespace (token lexeme #:skip? #t)]               ; handle whitespace
   [(from/stop-before "rem" "\n") (token 'REM lexeme)]  ; handle comments "rem"
   [(:or "print" "goto" "end" "+" ":" ";")              ; handle parsing operators
    (token lexeme lexeme)]
   [digits (token 'INTEGER (string->number lexeme))]    ; handle a single digit
   [(:or (:seq (:? digits) "." digits)                  ; handle compound digit expressions
         (:seq digits "."))
    (token 'DECIMAL (string->number lexeme))]
   [(:or (from/to "\""  "\"") (from/to "'" "'"))        ; handle strings
    (token 'STRING
           (substring lexeme
                      1 (sub1 (string-length lexeme))))]))

(provide basic-lexer)
#+END_SRC

** Testing the Lexer

#+BEGIN_SRC racket :tangle lexer-test.rkt
#lang br
(require "lexer.rkt" brag/support rackunit)

(define (lex str)
  (apply-port-proc basic-lexer str))

(check-equal? (lex "") empty)
(check-equal?
 (lex " ")
 (list (srcloc-token (token " " #:skip? #t)
                     (srcloc 'string 1 0 1 1))))
(check-equal?
 (lex "rem ignored\n")
 (list (srcloc-token (token 'REM "rem ignored")
                     (srcloc 'string 1 0 1 11))
       (srcloc-token (token 'NEWLINE "\n")
                     (srcloc 'string 1 11 12 1))))
(check-equal?
 (lex "print")
 (list (srcloc-token (token "print" "print")
                     (srcloc 'string 1 0 1 5))))
(check-equal?
 (lex "goto")
 (list (srcloc-token (token "goto" "goto")
                     (srcloc 'string 1 0 1 4))))
(check-equal?
 (lex "end")
 (list (srcloc-token (token "end" "end")
                     (srcloc 'string 1 0 1 3))))
(check-equal?
 (lex "+")
 (list (srcloc-token (token "+" "+")
                     (srcloc 'string 1 0 1 1))))
(check-equal?
 (lex ";")
 (list (srcloc-token (token ";" ";")
                     (srcloc 'string 1 0 1 1))))
(check-equal?
 (lex ":")
 (list (srcloc-token (token ":" ":")
                     (srcloc 'string 1 0 1 1))))
(check-equal?
 (lex "12")
 (list (srcloc-token (token 'INTEGER 12)
                     (srcloc 'string 1 0 1 2))))
(check-equal?
 (lex "1.2")
 (list (srcloc-token (token 'DECIMAL 1.2)
                     (srcloc 'string 1 0 1 3))))
(check-equal?
 (lex "12.")
 (list (srcloc-token (token 'DECIMAL 12.)
                     (srcloc 'string 1 0 1 3))))
(check-equal?
 (lex ".12")
 (list (srcloc-token (token 'DECIMAL .12)
                     (srcloc 'string 1 0 1 3))))
(check-equal?
 (lex "\"foo\"")
 (list (srcloc-token (token 'STRING "foo")
                     (srcloc 'string 1 0 1 5))))
(check-equal?
 (lex "'foo'")
 (list (srcloc-token (token 'STRING "foo")
                     (srcloc 'string 1 0 1 5))))
(check-exn exn:fail:read? (lambda () (lex "x")))
#+END_SRC

* The Tokenizer

#+BEGIN_SRC racket :tangle tokenizer.rkt
#lang br
(require "lexer.rkt" brag/support)

(define (make-tokenizer ip [path #f])
  (port-count-lines! ip)
  (lexer-file-path path)
  (define (next-token) (basic-lexer ip))
  next-token)

(provide make-tokenizer)
#+END_SRC

* The Parser

#+BEGIN_SRC racket :tangle parser.rkt
#lang brag
b-program : [b-line] (/NEWLINE [b-line])*
b-line : b-line-num [b-statement] (/":" [b-statement])* [b-rem]
@b-line-num : INTEGER
@b-statement : b-end | b-print | b-goto
b-rem : REM
b-end : /"end"
b-print : /"print" [b-printable] (/";" [b-printable])*
@b-printable : STRING | b-expr
b-goto : /"goto" b-expr
b-expr : b-sum
b-sum : b-number (/"+" b-number)*
@b-number : INTEGER | DECIMAL
#+END_SRC

#+BEGIN_SRC racket :tangle parser-test.rkt
#lang br
(require basic/parser basic/tokenizer brag/support)

(define str #<<HERE
10 print "hello" : print "world"
20 goto 9 + 10 + 11
30 end
HERE
)

(parse-to-datum (apply-tokenizer make-tokenizer str))

(define str2 #<<HERE
30 rem print 'ignored'
35
50 print "never gets here"
40 end
60 print 'three' : print 1.0 + 3
70 goto 11. + 18.5 + .5 rem ignored
10 print "o" ; "n" ; "e"
20 print : goto 60.0 : end
HERE
)

(parse-to-datum (apply-tokenizer make-tokenizer str2))
#+END_SRC

What if we just wrote out our source in a little lang, and then ran the result?

#+BEGIN_SRC racket :tangle parse-only.rkt
#lang br/quicklang
(require "parser.rkt" "tokenizer.rkt")

(define (read-syntax path port)
  (define parse-tree (parse path (make-tokenizer port path)))
  (strip-bindings
   #`(module basic-parser-mod basic/parse-only
       #,parse-tree)))
(module+ reader (provide read-syntax))

(define-macro (parser-only-mb PARSE-TREE)
  #'(#%module-begin
     'PARSE-TREE))
(provide (rename-out [parser-only-mb #%module-begin]))
#+END_SRC

#+BEGIN_SRC racket :tangle test.rkt
#lang basic/parse-only
10 print "hello" : print "world"
20 goto 9 + 10 + 11
30 end
#+END_SRC

Likewise, it's easy to make a similar basic/tokenize-only dialect that reveals the output from the tokenizer

#+BEGIN_SRC racket :tangle tokenize-only.rkt
#lang br/quicklang
(require brag/support "tokenizer.rkt")

(define (read-syntax path port)
  (define tokens (apply-tokenizer make-tokenizer port))
  (strip-bindings
   #`(module basic-tokens-mod basic/tokenize-only
       #,@tokens)))
(module+ reader (provide read-syntax))

(define-macro (tokenize-only-mb TOKEN ...)
  #'(#%module-begin
     (list TOKEN ...)))
(provide (rename-out [tokenize-only-mb #%module-begin]))
#+END_SRC

* The Reader

#+BEGIN_SRC racket :tangle main.rkt
#lang br/quicklang
(require "parser.rkt" "tokenizer.rkt")

(module+ reader
  (provide read-syntax get-info))

(define (read-syntax path port)
  (define parse-tree (parse path (make-tokenizer port path)))
  (strip-bindings
   #`(module basic-mod basic/expander
       #,parse-tree)))

(define (get-info port src-mod src-line src-col src-pos)
  (define (handle-query key default)
    (case key
      [(color-lexer)
       (dynamic-require 'basic-colorer 'color)]
      [else default]))
  handle-query)
#+END_SRC

* The Expander

Key Tasks:

- We need to convert each line of the source program -- that is, each b-line element -- into a function
- We need to make a hash table that maps line numbers to their associated functions, and a main program loop that looks up functions in this table and runs them
- We need to implement the behavior of our statements and expressions


#+BEGIN_SRC racket
#lang br/quicklang
(provide (matching-identifiers-out #rx"^b-" (all-defined-out)))

(define-macro (b-line NUM STATEMENT ...)
  (with-pattern ([LINE-NUM (prefix-id "line-" #'NUM
                                      #:source #'NUM)])
    (syntax/loc caller-stx
      (define (LINE-NUM) (void) STATEMENT ...))))

(define-macro (b-module-begin (b-program LINE ...))
  (with-pattern
      ([((b-line NUM STMT ...) ...) #'(LINE ...)]
       [(LINE-FUNC ...) (prefix-id "line-" #'(NUM ...))])
    #'(#%module-begin
       LINE ...
       (define line-table
         (apply hasheqv (append (list NUM LINE-FUNC) ...)))
       (void (run line-table)))))
(provide (rename-out [b-module-begin #%module-begin]))

(struct end-program-signal ())
(struct change-line-signal (val))

(define (b-end) (raise (end-program-signal)))
(define (b-goto expr) (raise (change-line-signal expr)))

(define (run line-table)
  (define line-vec
    (list->vector (sort (hash-keys line-table) <)))
  (with-handlers ([end-program-signal? (λ (exn-val) (void))])
    (for/fold ([line-idx 0])
              ([i (in-naturals)]
               #:break (>= line-idx (vector-length line-vec)))
      (define line-num (vector-ref line-vec line-idx))
      (define line-func (hash-ref line-table line-num))
      (with-handlers
          ([change-line-signal?
            (λ (cls)
              (define clsv (change-line-signal-val cls))
              (or
               (and (exact-positive-integer? clsv)
                    (vector-member clsv line-vec))
               (error
                (format "error in line ~a: line ~a not found"
                        line-num clsv))))])
        (line-func)
        (add1 line-idx)))))

(define (b-rem val) (void))
(define (b-print . vals)
  (displayln (string-append* (map ~a vals))))
(define (b-sum . vals) (apply + vals))
(define (b-expr expr)
  (if (integer? expr) (inexact->exact expr) expr))
#+END_SRC

* Into the Rapids: More BASIC

We will:

1. Write the syntax colorer
2. Extend our use of exceptions to support better line errors
3. Add variables and input
4. Support more math expressions and account for order of operations
5. Add conditionals
6. Add gosub and for loops

* Specification and Setup

Our lexer, tokenizer, parser and main module (containing our reader) will remain the same.

The expander will be trimmed down and our supporting structure types will be moved into a new "struct.rkt" module.
Our run function will go into run.rkt, and everything else (functions and macros that implement language constructs) will be moved
into a new "elements.rkt" module.

#+BEGIN_SRC racket :tangle expander.rkt
#lang br/quicklang
(require "struct.rkt" "run.rkt" "elements.rkt")
(provide (rename-out [b-module-begin #%module-begin])
         (all-from-out "elements.rkt"))

(define-macro (b-module-begin (b-program LINE ...))
  (with-pattern
    ([((b-line NUM STMT ...) ...) #'(LINE ...)]
     [(LINE-FUNC ...) (prefix-id "line-" #'(NUM ...))])
    #'(#%module-begin
       LINE ...
       (define line-table
         (apply hasheqv (append (list NUM LINE-FUNC) ...)))
       (void (run line-table)))))
#+END_SRC

#+BEGIN_SRC racket :tangle struct.rkt
#lang br
(provide (struct-out end-program-signal)
         (struct-out change-line-signal)
         (struct-out line-error))

(struct end-program-signal ())
(struct change-line-signal (val))
(struct line-error (msg))
#+END_SRC

#+BEGIN_SRC racket :tangle run.rkt
#lang br
(require "line.rkt" "struct.rkt")
(provide run)

(define (run line-table)
  (define line-vec
    (list->vector (sort (hash-keys line-table) <)))
  (with-handlers ([end-program-signal? (lambda (exn-val) (void))])
    (for/fold ([line-idx 0])
              ([i (in-naturals)]
               #:break (>= line-idx (vector-length line-vec)))
      (define line-num (vector-ref line-vec line-idx))
      (define line-func (hash-ref line-table line-num))
      (with-handlers
        ([change-line-signal?
          (lambda (cls)
            (define clsv (change-line-signal-val cls))
            (or
             (and (exact-positive-integer? clsv)
                  (vector-member clsv line-vec))
             (line-func "error in line ~a: line ~a not found" line-num clsv)))])
        (line-func)
        (add1 line-idx)))))
#+END_SRC

#+BEGIN_SRC racket :tangle elements.rkt
#lang br
(require "line.rkt" "go.rkt"
         "expr.rkt" "misc.rkt")

(provide
 (all-from-out "line.rkt" "go.rkt"
               "expr.rkt" "misc.rkt"))
#+END_SRC

#+BEGIN_SRC racket :tangle line.rkt
#lang br
(require "struct.rkt")
(provide b-line raise-line-error)

(define-macro (b-line NUM STATEMENT ...)
  (with-pattern ([LINE-NUM (prefix-id "line-" #'NUM
                                      #:source #'NUM)])
    (syntax/loc caller-stx
      (define (LINE-NUM #:error [msg #f])
        (with-handlers
          ([line-error?
            (lambda (le) (handle-line-error NUM le))])
          (when msg (raise-line-error msg))
          STATEMENT ...)))))

(define (raise-line-error str)
  (raise (line-error str)))

(define (handle-line-error num le)
  (error (format "error in line ~a: ~a"
                 num (line-error-msg le))))
#+END_SRC

#+BEGIN_SRC racket :tangle go.rkt
#lang br
(require "struct.rkt" "line.rkt")
(provide b-end b-goto)

(define (b-end) (raise (end-program-signal)))

(define (b-goto num-expr)
  (raise (change-line-signal num-expr)))
#+END_SRC

#+BEGIN_SRC racket :tangle expr.rkt
#lang br
(provide b-sum b-expr)

(define (b-sum . vals) (apply + vals))

(define (b-expr expr)
  (if (integer? expr)
      (inexact->exact expr)
      expr))
#+END_SRC

#+BEGIN_SRC racket :tangle misc.rkt
#lang br
(require "struct.rkt")
(provide b-rem b-print)

(define (b-rem val) (void))

(define (b-print . vals)
  (displayln (string-append* (map ~a vals))))
#+END_SRC

#+BEGIN_SRC racket :tangle sample.rkt
#lang basic
30 rem print 'ignored'
35
50 print "never gets here"
40 end
60 print 'three' : print 1.0 + 3
70 goto 11. + 18.5 + .5 rem ignored
10 print "o" ; "n" ; "e"
20 print : goto 60.0 : end
#+END_SRC

* The Syntax Colorer

#+BEGIN_SRC racket :tangle colorer.rkt
#lang br
(require "lexer.rkt" brag/support)
(provide basic-colorer)

(define (basic-colorer port)
  (define (handle-lexer-error excn)
    (define excn-srclocs (exn:fail:read-srclocs excn))
    (srcloc-token (token 'ERROR) (car excn-srclocs)))
  (define srcloc-tok (basic-lexer port)
    (with-handlers ([exn:fail:read? handle-lexer-error])
      (basic-lexer port)))
  (match srcloc-tok
    [(? eof-object?) (values srcloc-tok 'eof #f #f #f)]
    [else
     (match-define
       (srcloc-token
        (token-struct type val _ _ _ _ _)
        (srcloc _ _ _ posn span)) srcloc-tok)
     (define start posn)
     (define end (+ start span))
     (match-define (list cat paren)
       (match type
         ['STRING '(string #f)]
         ['REM '(comment #f)]
         ['ERROR '(error #f)]
         [else (match val
                 [(? number?) '(constant #f)]
                 [(? symbol?) '(symbol #f)]
                 ["(" '(parenthesis |(|)]
                 [")" '(parenthesis |)|)]
                 [else '(no-color #f)])]))
     (values val cat paren start end)]))
#+END_SRC
